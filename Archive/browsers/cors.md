## CORS 정책은 무엇일까 ?

> CORS (Cross-Origin Resource Sharing)

CORS 관련 이슈는 모두 **CORS 정책**을 위반했기 때문에 발생하는 것이다.

CORS는 Cross-Origin Resource Sharing의 줄임말로, 한국어로 직영하면 교차 출처 리소스 공유 이다.
여기서 **교차 출처** 는 **'다른 출처'** 를 의미한다.

다른 출처 간의 리소스 공유에 대해 알아보기에 앞서 출처 **(Origin)** 의 의미를 정확히 하고 넘어가자.

### 출처 (Origin) ?

서버의 위치를 의마하는 `https://google.com` 와 같은 URL은 여러 개의 요소로 구성되어있다.

![](https://hanseul-lee.github.io/2020/12/24/20-12-24-URL/0.png)
이때 출처는 `Protocol`과 `Host`, `Port`를 의미한다. 즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것이다.

또한 출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 HTTP, HTTPS 프로토콜의 기본 포트 번호가 정해져있기 때문이다. (HTTP 80, HTTP 443)

브라우저의 개발자 도구의 console 에서 `Location` 객체가 가지고 있는 `origin` 프로퍼티에 접근함으로써 손 쉽게 애플리케이션이 실행되고 있는 출처를 알아낼 수도 있다.

```js
console.log(location.origin);
```

### SOP (Same-Origin Policy)

웹 생태계에는 다른 출처로의 리소스 요청을 제한하는 것과 관련된 두 가지 정책이 존재한다. 한 가지는 CORS, 그리고 또 한 가지는 **SOP (Same-Origin Policy)** 이다.

SOP는 말 그대로 `같은 출처에서만 리소르를 공유할 수 있다.` 라는 규칙을 가진 정책이다.

그러나 웹이라는 오픈스페이스 환경에서 다른 출처에 있는 리소스를 사용하는 일은 굉장히 흔해 무작정 막을 수도 없는 노릇이니 몇 가지 예외 조항을 두고, 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그 중 하나가 `cors 정책을 지킨 리소스 요청` 이다.

만약 다른 출처로 리소스를 요청한다면 SOP 정책을 위반한 것이 되고, 거기다가 SOP의 예외 조항인 CORS 정책까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게 되는 것이다.

출처가 다른 두 개의 애플리케이션이 소통하는 환경은 꽤 위험하다.

최근에는 자바스크립트 코드를 난독화해서 읽기 어렵다고 하지만, 난독화는 어디까지 난독화일 뿐이다.

이런 상황에서 통신에 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 구경한 후 CSRF나 XSS와 같은 방법을 사용하여 애플리케이션에서 코드가 실행된 것처럼 꾸며 사용자의 정보를 탈취하기가 쉬워진다.

### 출처 구분

URL 의 구성 요소 중 `Scheme`, `Host`, `Port` 이 세가지만 동일하면 된다.
|URL|같은 출처 ?| 이유|
|:---:|:---:|:---:|
|`https://sihyeon.github.io/about`|O|Scheme, Host, Port가 동일
|`https://sihyeon.github.io/about?q=안녕`|O|Scheme, Host, Port가 동일
|`https://user:password@sihyeon.github.io/about`|O|Scheme, Host, Port가 동일
|`http://sihyeon.github.io`|X|Scheme 이 다름
|`https://api.github.io`|X|Host 가 다름
|`https://sihyeon.naver.com`|X|Host 가 다름

> CORS 는 브라우저의 구현 스펙에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.

### CORS는 어떻게 동작할까요~?

웹 클라이언트 애플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 `Origin` 이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.

> `Origin: https://sihyeon.github.io`

이후 서버가 요청에 대한 응답을 할 때 response header의 `Access-Control-Allow-Origin` 이라는 값에 '이 리소스를 접근하는 것이 허용된 출처' 를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 `Origin` 과 서버가 보내준 응답의 `Access-Control-Allow-Origin` 을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

사실 CORS 가 동작하는 방식은 한 가지가 아니라 세 가지의 시나리오에 따라 변경되기 때문에 에러가 어떤 시나리오에 해당하는지 잘 파악하면 에러를 고치는 것이 한결 쉬울 것이다.

#### 1. Preflight Request

`Preflight` 방식은 일반적으로 우리가 웹 애플리케이션을 개발할 때 가장 많이 마주치는 시나리오이다. 이 시나리오에 해당하는 상황일 때 브라우저는 요청을 한 번에 보내지 않고 예비 요청과 본 요청으로 나누어서 서버로 전송한다.

이때 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 Preflight 라고 부르는 것이며, 이 예비 요청에는 HTTP 메소드 중 `OPTIONS` 메소드가 사용된다. 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한 지 확인하는 것이다.

이 과정을 간단한 플로우 차트로 나타내보면 대략 이런 느낌이다.

![](https://evan-moon.github.io/static/c86699252752391939dc68f8f9a860bf/21b4d/cors-preflight.png)

우리가 자바스크립트의 `fetch` API를 사용하여 브라우저에게 리소스를 받아오라는 명령을 내리면 브라우저는 서버에게 예비 요청을 먼저 보내고, 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는 지에 대한 정보를 응답 헤더에 담아서 브라우저에게 다시 보내주게 된다.

이후 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교한 후, 이 요청을 보내는 것이 안전하다고 판단되면 같은 엔드 포인트로 다시 본 요청을 보내게 도니다. 이후 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.

#### 2. Simple Request

`Simple Request`는 예비 요청을 보내지 않고 바로 서버에게 본 요청을 한 후, 서버가 이에 대한 응답의 헤더에 `Access-Control-Allow-Origin`과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다. 즉, `Preflight`와 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다.

![](https://evan-moon.github.io/static/d8ed6519e305c807c687032ff61240f8/21b4d/simple-request.png)

하지만 아무 때나 단순 요청을 사용할 수 있는 것은 아니고, 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있다. 게다가 이 조건이 조금 까다롭기 때문에 일반적인 방법으로 웹 애플리케이션 아키텍처를 설계하게 되면 거의 충족시키기 어려운 조건들이다.

**_1. 요청의 메소드는 `GET`, `HEAD`, `POST` 중 하나여야 한다._**

**_2. `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `DPR`, `Downlink`, `Save-Data`, `Viewport-Width`, `Width`를 제외한 헤더를 사용하면 안된다._**

**_3. 만약 `Content-type`을 사용하는 경우에는 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 만 허용된다._**

사실 1번 조건의 경우는 그냥 `PUT`이나 `DELETE` 같은 메소드를 사용하지 않으면 되는 것 뿐이니 그렇게 보기 드문 상황은 아니지만, 2번이나 3번 조건 같은 경우는 조금 까다롭다.

애초에 저 조건에 명시된 헤더들은 진짜 기본적인 헤더들이기 때문에, 복잡한 사용 웹 애플리케이션에서 이 헤더들 외에 추가적인 헤더를 사용하지 않는 경우는 드물다. 당장 사용자 인증에 사용되는 `Authorization` 헤더 조차 저 조건에는 포함되지 않는다.

게다가 대부분의 HTTP API는 `text/xml`이나 `application/json`컨텐츠 타입을 가지도록 설계되기 때문에 사실 상 이 조건들을 모두 만족시키는 상황을 만들기는 그렇게 쉽지 않은 것이 현실이다.

#### 3. Credentialed Request

3번째 시나리오는 인증된 요청을 사용하는 방법이다. 이 시나리오는 COR의 기본적인 방식이라기 보다는 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다.

기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 `XMLHttpRequest`객체나 `fetch` API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 `credentials` 옵션이다.

이 옵션에는 3가지의 값을 사용할 수 있으며, 각 값들이 가지는 의미는 다음과 같다.
|옵션|설명|
|:--:|:--:|
| same-origin (default) | 같은 출처 간 요청에만 인증 정보를 담을 수 있다.|
| include | 모든 요청에 인증 정보를 담을 수 있다.|
| omit | 모든 요청에 인증 정보를 담지 않는다.|

만약 여러분이 `same-origin`이나 `include`와 같은 옵션을 사용하여 리소스 요청에 인증 정보가 포함된다면, 이제 브라우저는 다른 출처의 리소스를 요청할 때 단순히 `Access-Control-Allow-Origin`만 확인하는 것이 아니라 좀 더 빡빡한 검사 조건을 추가하게 된다.

요청에 인증 정보가 담겨있는 상태에서 다른 출처의 리소스를 요청하게 되면 브라우저는 CORS 정책 위반 여부를 검사하는 룰에 다음 두가지를 추가하게 된다.

1. `Access-Control-Allow-Origin`에는 \*을 사용할 수 없으며, 명시적인 URL이어야 한다.
2. 응답 헤더에는 반드시 `Access-Control-Allow-Credentials: true`가 존재해야한다.

인증까지 얽혀있는 이 시나리오는 다른 시나리오에 비해서 다소 복잡하게 느껴질 수는 있지만, 이렇게 CORS 정책에 대한 다양한 시나리오를 알아두면 실제 상황에서 CORS 정책 위반으로 인한 문제가 발생했을 경우 삽질해야하는 시간을 크게 단축할 수 있다.

### CORS 해결 방법

지금까지 CORS가 무엇인지, 어떤 상황에서 CORS 정책이 적용되고 위반되는 것인지 알아봤다면 이번 섹션에서는 실질적으로 CORS 정책 위반으로 인한 문제가 발생했을 경우에 해결할 수 있는 방법을 알아보자.

#### Access-Control-Allow-Origin 세팅

CORS 정책 위반으로 인한 문제를 해결하는 가장 대표적인 방법은, 그냥 정석대로 서버에서 `Access-Control-Allow-Origin` 헤더에 알맞은 값을 세팅해 주는 것이다.

이때 와일드 카드인 `*`을 사용하여 헤더를 세팅하면 모든 출처에서 오는 요청을 다 받겠다는 의미가 되므로 당장은 편할 수 있겠지만, 바꿔서 생각하면 정체 모르는 출처에서 오는 요청까지 모두 받겠다는 의미이므로 보안적으로 심각한 이슈가 발생할 가능성이 높다.

그러니 가급적이면 `Access-Control-Allow-Origin: https://sihyeon.github` 와 같이 출처를 명시해주자.

이 헤더는 Nginx나 Apache와 같은 서버 엔진의 설정에서 추가할 수도 있지만, 아무래도 복잡한 세팅을 하기는 불편하기 때문에 소스 코드 내에서 응답 미들웨어 등을 사용하여 세팅하는 것을 추천한다. Spring, Express, Django 와 같이 이름있는 백엔드 프레임워크는 모두 CORS 관련 설정을 위한 세팅이나 미들웨어 라이브러리를 제공하고 있으니 세팅 자체가 어렵지는 않을 것이다.

### Webpack Dev Server로 리버스 프록싱하기

사실 CORS를 가장 많이 마주치는 환경은 바로 로컬에서 프론트엔드 애플리케이션을 개발하는 경우라고 해도 과언이 아니다. 백엔드에는 이미 `Access-Control-Allow-Origin` 헤더가 세팅되어있겠지만, 이 중요한 헤더에다가 `http://localhost:3000` 같은 범용적인 출처를 넣어주는 경우는 드물기 때문이다.

프론트엔드 개발자는 대부분 웹팩과 `webpack-dev-server`를 사용하여 자신의 머신에 개발 환경을 구축하게 되는데, 이 라이브러리가 제공하는 프록시 기능을 사용하면 아주 편하게 CORS 정책을 우회할 수 있다.

```js
module.exports = {
  devServer: {
    proxy: {
      "/api": {
        target: "https://api.sihyeon.com",
        changeOrigin: true,
        pathRewrite: { "^/api": "" },
      },
    },
  },
};
```

이렇게 설정을 해놓으면 로컬 환경에서 `/api`로 시작하는 URL로 보내는 요청에 대해 브라우저는 `localhost:8000/api`로 요청을 보낸 것으로 알고 있지만, 사실 뒤에서 웹팩이 `https://api.sihyeon.com`으로 요청을 프록싱해주기 때문에 마치 CORS 정책을 지킨 것처럼 브라우저를 속이면서도 우리는 원하는 서버와 자유롭게 통신을 할 수가 있다. 즉, 프록싱을 통해 CORS 정책을 우회할 수 있는 것이다.

### 마치며

CORS 정책 위반으로 생기는 문제를 해결할 때 가장 번거로운 점은 문제를 겪는 사람과 문제를 해결해야하는 사람이 다르다는 것이다.

CORS 정책은 브라우저의 구현 스펙이기 때문에 정책 위반으로 인해 문제를 겪는 사람은 대부분 프론트엔드 개발자이지만, 정작 문제를 해결하기 위해서는 백엔드 개발자가 서버 애플리케이션의 응답헤더에 올바른 `Access-Control-Allow-Origin`이 내려올 수 있도록 세팅해줘야 하기 때문이다.

물론 `webpack-dev-server`의 프록싱 옵션을 이용해 자체적으로 해결하는 방법도 있지만, 이 방법은 로컬 개발 환경에서만 통하는 방법인데다가, 근본적인 문제 해결 방법이 아니기 때문에 결국 운영 환경에서 CORS 정책 위반 문제를 해결하기 위해서는 백엔드 개발자의 도움이 필요할 수 밖에 없다.

사실 CORS 정책 위반을 해결하는 방법 자체가 그렇게 어렵고 복잡한 편은 아니라 프론트엔드 개발자나 벡엔드 개발자 중 한 명이라도 이 정책에 대해서 잘 알고 있는 경우라면 손쉽게 문제를 해결할 수 있다.

그러나 반대로 경험이 힘든 경우 좀처럼 감을 잡기가 참 힘들다.

이상으로 cors 에 대해 알아보며 한 정리를 마친다.

[이 블로그 베꼈어요.](https://evan-moon.github.io/2020/05/21/about-cors/)
