## 자바스크립트

### 호이스팅

```js
console.log(test); // undefined

var test; // 변수 선언
```

js 엔진은 모든 선언문이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다.
런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되고 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지 상관없이 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 한다.

### var 키워드

var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

1. 변수 중복 선언 허용
2. 함수 레벨 스코프만을 지역 스코프로 인정
3. 변수 호이스팅

### let, var

1. 변수 중복 선언 금지

2. 블록 레벨 스코프

3. 변수 호이스팅
   var 로 선언한 변수와 달리 let 변수로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
   let 키워드로 선언한 변수는 '선언 단계' 와 '초기화 단계' 가 분리되어 진행되는데 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을때 실행된다.
   만약 초기화 단계가 실행되기 전에 변수에 접근하려고 하면 참조 에러가 발생된다.

   > let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문) 까지 변수를 참조할 수 없다.
   > 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대 (TDZ: Temporal Dead Zone)** 이라 부른다.
   > ![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/15_3.jpg)

4. 전역 객체와 let
   let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo 와 같이 접근할 수 없다.

### const

const 키워드는 상수(constant) 를 선언하기 위해 사용하지만, 반드시 상수만을 위해 사용하지는 않는다.
const 키워드의 특징은 let 과 대부분 동일하므로 let 키워드와 다른 점을 알아보자.

1. 선언과 초기화
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
   그렇지 않을 경우 Syntax Error 가 발생한다.

2. 재할당 금지
   var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.

3. 상수
   const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
   원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 없기 때문이다.
   이러한 특징을 이용해 const 키워드로 상수를 표현한다.

### Symbol type

심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.

### 정적 타이핑

C 나 JAVA 같은 정적 타입언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에서 타입 체크를 수행한다. 만약 타입체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.

### 동적 타이핑

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.
var, let, const 키워드를 사용하여 변수를 선언한다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 **(타입 추론)** 된다.
**재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.**
이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 한다.

### 타입변환과 단축 평가

#### 명시적 타입 변환

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅** 이라 한다.

#### 명시적 타입 변환 예시

- -> 문자열
  1. String 생성자를 new 없이 호출
  2. Object.prototype.toString 메서드
  3. 문자열 연결 연산자 이용
- -> 숫자
  1. Number 생성자를 new 없이 호출
  2. parseInt, parseFloat 함수를 사용
  3. `+` 단항 산술 연산자를 이용
  4. `*` 산술 연산자를 이용
- -> 불리언
  1.  Boolean 생성자 new 없이 호출
  2.  ! 부정 논리 연산자를 두 번 사용

#### 암묵적 타입 변환

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환** 또는 **강제 타입 변환** 이라 한다.

### truthy / falsy

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) 또는 Falsy 값 (거짓으로 평가되는 값) 으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true 로, Falsy 값은 false 로 암묵적 타입 변환 된다.

아래 값들은 false 로 평가되는 Falsy 값이다.

```js
false
undefined
null
0, -0
Nan
'' (빈 문자열)
```

Falsy 값에 ! 연산자를 붙이면, 모두 Truthy 값으로 평가되어 실행 가능해진다.

```js
// 아래의 조건문은 모두 코드 블록을 실행한다.
if (!false) console.log(false + " is falsy value");
if (!undefined) console.log(undefined + " is falsy value");
if (!null) console.log(null + " is falsy value");
if (!0) console.log(0 + " is falsy value");
if (!NaN) console.log(NaN + " is falsy value");
if (!"") console.log("" + " is falsy value");
```
