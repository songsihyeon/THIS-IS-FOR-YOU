## 자바스크립트

### 호이스팅

```js
console.log(test); // undefined

var test; // 변수 선언
```

js 엔진은 모든 선언문이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다.
런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되고 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지 상관없이 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 한다.

### var 키워드

var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

1. 변수 중복 선언 허용
2. 함수 레벨 스코프만을 지역 스코프로 인정
3. 변수 호이스팅

### let, var

1. 변수 중복 선언 금지

2. 블록 레벨 스코프

3. 변수 호이스팅
   var 로 선언한 변수와 달리 let 변수로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
   let 키워드로 선언한 변수는 '선언 단계' 와 '초기화 단계' 가 분리되어 진행되는데 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을때 실행된다.
   만약 초기화 단계가 실행되기 전에 변수에 접근하려고 하면 참조 에러가 발생된다.

   > let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문) 까지 변수를 참조할 수 없다.
   > 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대 (TDZ: Temporal Dead Zone)** 이라 부른다.
   > ![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/15_3.jpg)

4. 전역 객체와 let
   let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo 와 같이 접근할 수 없다.

### const

const 키워드는 상수(constant) 를 선언하기 위해 사용하지만, 반드시 상수만을 위해 사용하지는 않는다.
const 키워드의 특징은 let 과 대부분 동일하므로 let 키워드와 다른 점을 알아보자.

1. 선언과 초기화
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
   그렇지 않을 경우 Syntax Error 가 발생한다.

2. 재할당 금지
   var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.

3. 상수
   const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
   원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 없기 때문이다.
   이러한 특징을 이용해 const 키워드로 상수를 표현한다.

### Symbol type

심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.

### 정적 타이핑

C 나 JAVA 같은 정적 타입언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에서 타입 체크를 수행한다. 만약 타입체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.

### 동적 타이핑

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.
var, let, const 키워드를 사용하여 변수를 선언한다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 **(타입 추론)** 된다.
**재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.**
이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 한다.

### 타입변환과 단축 평가

#### 명시적 타입 변환

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅** 이라 한다.

#### 명시적 타입 변환 예시

- -> 문자열
  1. String 생성자를 new 없이 호출
  2. Object.prototype.toString 메서드
  3. 문자열 연결 연산자 이용
- -> 숫자
  1. Number 생성자를 new 없이 호출
  2. parseInt, parseFloat 함수를 사용
  3. `+` 단항 산술 연산자를 이용
  4. `*` 산술 연산자를 이용
- -> 불리언
  1.  Boolean 생성자 new 없이 호출
  2.  ! 부정 논리 연산자를 두 번 사용

#### 암묵적 타입 변환

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환** 또는 **강제 타입 변환** 이라 한다.

### truthy / falsy

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) 또는 Falsy 값 (거짓으로 평가되는 값) 으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true 로, Falsy 값은 false 로 암묵적 타입 변환 된다.

아래 값들은 false 로 평가되는 Falsy 값이다.

```js
false
undefined
null
0, -0
Nan
'' (빈 문자열)
```

Falsy 값에 ! 연산자를 붙이면, 모두 Truthy 값으로 평가되어 실행 가능해진다.

```js
// 아래의 조건문은 모두 코드 블록을 실행한다.
if (!false) console.log(false + " is falsy value");
if (!undefined) console.log(undefined + " is falsy value");
if (!null) console.log(null + " is falsy value");
if (!0) console.log(0 + " is falsy value");
if (!NaN) console.log(NaN + " is falsy value");
if (!"") console.log("" + " is falsy value");
```

### 고차함수

고차 함수 (Higher-Order Function, HOF) 는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말하낟.

자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달할 수 있으며 반환할 수도 있다.

고차 함수는 외부 상태의 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에 기반을 두고있다.

### 객체 리터럴

자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체이다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식) 은 모두 객체이다. 원시 타입은 단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다.

```js
var person = {
  name: "Lee",
  age: 20,
};
```

### 함수와 메서드의 차이점

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드(method)라 부른다. 객체 내부에서 객체의 프로퍼티(상태)를 참조하고 조작할 수 있는 동작을 메서드라 부른다.

즉, 메서드는 객체에 묶여 있는 함수를 의미한다.

### 자바스크립트에서 객체를 생성하는 방법

자바스크립트는 '프로토타입 기반 객체지향 언어' 로써 '클래스 기반 객체지향 언어' 와는 달리 다양한 객체 생성 방법을 지원한다.

```
   1. 객체 리터럴
   2. Object 생성자 함수
   3. 생성자 함수
   4. Object.create 메서드
   5. 클래스(ES6)
```

### 전역 객체

- 전역 객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다.
- 클라이언트 사이드 환경(브라우저) 에서는 window, 서버 사이드 환경(Node.js) 에서는 global 객체를 의미한다.
- 전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array...) 들과 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

### 원시 값과 객체 비교

동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유

1. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value) 이다. 이에 비해 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.
2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간) 에는 참조 값(메모리 주소)이 저장된다.
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.

### 함수 선언문과 함수 표현식의 차이

함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.

### 스코프

스코프는 유효 범위 라는 뜻으로, 식별자(변수)가 유효한 범위를 말한다.

자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 따라서 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

스코프는 크게 전역 스코프와 지역 스코프로 구분된다.

이는 상대적인 개념이며 전역이란 코드의 가장 바깥 영역을 말한다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 이 전역 변수는 어디서든 참조할 수 잇다.

지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만드는데, 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.
지역 변수는 자신의 스코프와 하위 지역 스코프에서 유효하다.

### 렉시컬 스코프

함수를 어디서 '호출' 했는 지가 아닌 어디서 '정의' 했는 지에 따라 함수의 상위 스코프를 결정하는 것이 정적 스코프 즉, 렉시컬 스코프를 의미한다.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

소스코드의 실행에 있어서 foo 함수 내부에서 bar 함수를 '호출' 하더라도, bar 함수는 foo 함수와 동일한 스코프인 전역 스코프에 '정의' 되어 있기 때문에 foo 함수 내부의 x=10 을 참조할 수 없다.

따라서 foo, bar 의 호출한 결과는 모두 1로 반환된다. 이런 자바스크립트의 정적인 스코프 특징을 '렉시컬 스코프' 라고 한다.

### 함수와 일급 객체

#### 일급 객체

다음과 같은 조건을 만족하는 객체를 일급 객체 라 한다.

1. 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다.

일급 객체로써 함수가 가지는 가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 잇으며, 함수의 반환값으로 사용할 수도 있다는 것이다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중 하나이다.

#### 함수형 프로그래밍

외부 상태를 변경하지 않고, 외부 상태에 의존하지도 않는 함수를 순수 함수라고 한다. 순수 함수를 통해 side effect 를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.

- 순수함수 : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 side effect 가 없는 함수
- 비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 side effect 가 있는 함수

### 프로토타입

#### 객체지향 프로그래밍

여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

#### 객체지향 프로그래밍의 특징

1. 추상화
2. 캡슐화
3. 상속
4. 다형성

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

프로토타입은 상속을 구현하기 위해 사용된다.

자바스크립트에서 기본 데이터 타입을 제외한 모든 것은 객체이다.

객체가 만들어지기 위해서는 자신을 만드는 데 사용된 원형인 프로토타입 객체를 이용하여 객체를 만든다.

이때 만들어진 객체 안에 `__proto__` 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있다.

이 숨겨진 링크를 프로토타입이라고 한다.

`__proto__` 속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다.
이런 프로토타입 체인 구조 때문에 모든 객체는 Object 의 자식이라고 불리고, Object Prototype Object 에 있는 모든 속성을 사용할 수 있다.

### this

this 는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.

this 를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

this 는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.

단 this 가 가리키는 값 즉, this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

#### this 바인딩

바인딩이란 식별자(변수) 와 값(원시 값 또는 객체)을 연결하는 과정을 의미한다.

예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다.

this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다) 와 this 가 가리킬 객체를 바인딩하는 것이다.

### 실행 컨텍스트

실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

실행 컨텍스트는 ① 실행 컨택스트 스택, ② 렉시컬 환경으로 구성되어 있다.

① 실행 컨텍스트 스택은 코드의 실행 순서를 관리하는 자료구조로, L.I.F.O(Last In First Out) 구조로 들어오는 코드를 관리한다.

② 렉시컬 환경은 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다.

② 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.

즉, ② 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.

### 클로저

> 클로저는 자신이 선언될 당시의 환경을 기억하는 함수이다.

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 (실행 컨텍스트 스택에서 push 되더라도) 렉시컬 환경에 남아 참조가 가능하다.

#### 클로저의 장점

클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.

다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태변경을 허용하기 위해 사용한다.

#### 클로저 생성 방법

1. 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환 값으로 사용될 때
2. 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
3. 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때

```js
var name = `Global`;
function outer() {
  var name = `closure`;
  return function inner() {
    console.log(name);
  };
}

var callFunc = outer();
callFunc();
```

위 코드에서 `callFunc` 를 클로저라고 한다. `callFunc` 호출에 의해 name 이라는 값이 console 에 찍히는데, 찍히는 값은 `Global` 이 아니라 `closure` 라는 값이다. 즉, `outer` 함수의 `context` 에 속해있는 변수를 참조하는 것이다. 여기서 `outer` 함수의 지역변수로 존재하는 `name` 변수를 `free variable (자유변수)` 라고 한다.

이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 `클로저` 라고 한다.

### 브라우저 렌더링 과정

1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.

- 주소창에 직접 입력하거나, 클릭을 통해 해당 웹 페이지에 접근한다.
- 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.

2. 서버에서 응답으로 받은 HTML 데이터를 파싱한다. (바이트 -> 문자 -> 토큰 -> 노드 -> DOM)

- 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다.
- 이때 서버는 브라우저가 요청한 HTML 파일을 읽어들여 메모리에 저장한 다음 메모리에 저장된 바이트 (2진수)를 인터넷을 경유하여 응답한다.
- 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다.
- 따라서 응답된 바이트 형태의 HTML 문서를 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다.
- 문자열로 변환된 HTML 문서를 읽어들여 문법적 의미를 갖는 코드의 최소 단위인 토큰(token)들로 분해한다.
- 각 토큰들을 객체로 변환하여 노들들을 생성한다. 토큰의 내용에 따라 1. 문서 노드, 2. 요소 노드, 3. 어트리뷰트 노드, 4. 텍스트 노드가 생성된다.

3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.

- HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 갖는다.
- 이때 HTML 요소 간에는 중첩 관계에 의해 부모자식 관계가 형성된다.
- 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다.
- 이 노드들로 구성된 트리 자료구조를 DOM 이라 부른다.

4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다. (바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM)

- HTML 데이터와 마찬가지로 파싱하여 CSSOM 트리 구조로 나타낸다.

5. DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 형성한다.

- 렌더링 언진에 의해 문서의 처음부터 끝까지 해석이 완료되어 DOM 트리와 CSSOM 트리가 완성된다면, 이 둘을 바탕으로 렌더 트리를 생성한다.

6. 렌더 트리에서 레이아웃을 실행한다.

- 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기) 를 계산한다.

7. 개별 노드를 화면에 페인트 한다.

- 이후 레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력되면 렌더링이 완료된다.

### 이벤트

#### 이벤트 전파

DOM 트리 상에 존재하는 모든 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.

사용자의 다양한 입력을 통해 동적으로 생성되는 이벤트 객체는 이벤트를 발생시킨 타겟(target)을 중심으로 DOM 트리를 통해 전파된다.

전파되는 방향에 따라 3단계로 분류

- 캡처링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계 : 이벤트가 이벤트 타깃에 도달
- 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/37_7.png)

이벤트 캡처링 단계라면 HTML > BODY > DIV 순으로 상위 노드에서 하위 노드로 내려오며 이벤트를 캐치할 것이다.

하지만 브라우저는 기본적으로 이벤트 버블링 단계인 우리가 클릭하고자 한 이벤트 객체의 타깃인 `<div>` 에 도달한 후 다시 해당 하위 노드에서 상위 노드로 돌아가는 과정에서 이벤트를 캐치하기 때문이다.

#### 이벤트 위임

연속되는 태그에 대해서는 공통적으로 이벤트를 줘야할 때 우리가 이벤트 핸들러를 바인딩할 해당 요소의 부모 요소에게 이를 위임하여 이벤트를 진행하는 것을 이벤트 위임이라고 한다.

> - e.preventDefault : 요소 태그의 기본 동작을 중단하는 메서드
> - e.stopPropagation : 이벤트 전파를 중지시키는 메서드

### 비동기 프로그래밍

#### 동기와 비동기의 차이점

- 동기 : 현재 실행 중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 동기(synchronous) 처리 방식이라고 한다.

- 비동기 : 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기(asynchronous) 처리 방식이라고 한다.

- 대표적으로 `setTimeout/setInterval`, `HTTP 요청`, `이벤트 핸들러` 는 비동기 처리 방식으로 동작한다.

#### 이벤트 루프와 태스크 큐

자바스크립트는 싱글 스레드로 동작하기 때문에 한번에 하나의 태스크만 처리할 수 있다 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다.

예를들어, HTML 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 한다.

이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프 (event loop) 다.

![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/39_6.jpg)

구글의 v8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.

#### 콜 스택 (call stack)

- 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택이다.
- 함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트) 가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않는다.

#### 힙 (heap)

- 힙은 객체가 저장되는 메모리 공간이다.
  콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
- 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다.
  객체는 원시 값과는 달리 크기가 정해져 잇지 않으므로 할당해야할 메모리 공간의 크기를 런타임에 동적 할당 해야한다.
  따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다는 특징이 있다.

이처럼 콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜스택을 통해 요청된 작업을 순차적으로 순차적으로 실행할 뿐이다.

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js 가 담당한다.

> ex)
>
> - 비동기 방식으로 동작하는 setTimeout 의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당한다.
> - 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js 가 담당한다.

이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

#### 태스크 큐

setTimeout 이나 setInterval 과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.

##### 큐

스택 자료구조와 달리 F.I.F.O (선입선출) 형식을 띈다.

#### 이벤트 루프

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등) 가 있는지 반복해서 확인한다.
- 만약 콜 스택이 비어있고 태스크 큐에 대기중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.

#### 마이크로 태스크 큐

마이크로 태스크 큐 는 태스크 큐 와 별도의 큐로 후속 처리 메서드의 콜백 함수가 일지 저장된다.

콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 **마이크로 태스크 큐는 태스크 큐보다 우선순위가 높다.**

### Ajax

Ajax(Asynchronous Javascript and XML)란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다.

Ajax 로 HTTP 요청을 보내는 방법

1. XMLHttpRequest

2. Fetch

> XMLHttpRequest 와 fetch 의 차이
> fetch 메서드는 Promise 를 기반으로 구성되어 있어서 더 간편하게 사용할 수 있다.

### REST API

REST 는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍쳐이고,
REST API 는 REST 를 기반으로 서비스 API 를 구현한 것을 의미한다.

REST 의 기본 원칙을 성실히 지킨 서비스 디자인을 'RESTful' 이라고 표현한다.

#### HTTP 상태 코드

- 2XX
  - 200 : OK | 요청이 성공적으로 보내졌음을 의미
  - 201 : Created | 요청이 성공적이였으며 새로운 리소스가 생성되었음을 의미
- 4XX
  - 400 : Bad Request | 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미
  - 401 : Unauthorized | 비인증된 요청임을 의미
  - 403 : Forbidden | 리소스에 접근할 권리를 갖고있지 않음을 의미
  - 404 : Not Found | 요청받은 리소스를 찾을 수 없음을 의미
- 5XX
  - 500 : Internal Server Error | 서버가 처리 방법을 모르는 상황을 의미

### Promise

ES6 에서 도입된, 콜백 함수의 문제점인 비동기 처리를 해결하기 위한 패턴

#### 콜백함수

자바스크립트에서 콜백 함수는 다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출되는 것을 의미한다.

비동기적으로 처리되는 비동기 방식의 함수이다.

### async/await

async/await 는 프로미스를 기반으로 동작하기 때문에 프로미스의 then/catch/finally 등의 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기처리 처럼 프로미스를 사용할 수 있다.

다시 말해, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.

#### Promise 와 async/await 의 차이점

1. 에러 핸들링
   - Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링을 해야한다.
   - async/await 은 try/catch 를 통해 에러를 처리할 수 있다.
2. 코드 가독성
   - Promise 의 후속 처리 메서드인 .then() 의 hell 의 가능성
   - async/await 은 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있기 때문에 코드 흐름을 이해하기 쉽다.
