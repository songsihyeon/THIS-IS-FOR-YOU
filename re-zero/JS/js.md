## 자바스크립트

### 호이스팅

```js
console.log(test); // undefined

var test; // 변수 선언
```

js 엔진은 모든 선언문이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다.
런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되고 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지 상관없이 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 한다.

### var 키워드

var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

1. 변수 중복 선언 허용
2. 함수 레벨 스코프만을 지역 스코프로 인정
3. 변수 호이스팅

### let, var

1. 변수 중복 선언 금지

2. 블록 레벨 스코프

3. 변수 호이스팅
   var 로 선언한 변수와 달리 let 변수로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
   let 키워드로 선언한 변수는 '선언 단계' 와 '초기화 단계' 가 분리되어 진행되는데 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을때 실행된다.
   만약 초기화 단계가 실행되기 전에 변수에 접근하려고 하면 참조 에러가 발생된다.

   > let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문) 까지 변수를 참조할 수 없다.
   > 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대 (TDZ: Temporal Dead Zone)** 이라 부른다.
   > ![](https://github.com/junh0328/prepare_frontend_interview/raw/main/images/15_3.jpg)

4. 전역 객체와 let
   let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo 와 같이 접근할 수 없다.

### const

const 키워드는 상수(constant) 를 선언하기 위해 사용하지만, 반드시 상수만을 위해 사용하지는 않는다.
const 키워드의 특징은 let 과 대부분 동일하므로 let 키워드와 다른 점을 알아보자.

1. 선언과 초기화
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
   그렇지 않을 경우 Syntax Error 가 발생한다.

2. 재할당 금지
   var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.

3. 상수
   const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
   원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 없기 때문이다.
   이러한 특징을 이용해 const 키워드로 상수를 표현한다.

### Symbol type

심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.

### 정적 타이핑

C 나 JAVA 같은 정적 타입언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에서 타입 체크를 수행한다. 만약 타입체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.

### 동적 타이핑

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.
var, let, const 키워드를 사용하여 변수를 선언한다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 **(타입 추론)** 된다.
**재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.**
이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 한다.

### 타입변환과 단축 평가

#### 명시적 타입 변환

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅** 이라 한다.

#### 명시적 타입 변환 예시

- -> 문자열
  1. String 생성자를 new 없이 호출
  2. Object.prototype.toString 메서드
  3. 문자열 연결 연산자 이용
- -> 숫자
  1. Number 생성자를 new 없이 호출
  2. parseInt, parseFloat 함수를 사용
  3. `+` 단항 산술 연산자를 이용
  4. `*` 산술 연산자를 이용
- -> 불리언
  1.  Boolean 생성자 new 없이 호출
  2.  ! 부정 논리 연산자를 두 번 사용

#### 암묵적 타입 변환

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환** 또는 **강제 타입 변환** 이라 한다.

### truthy / falsy

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) 또는 Falsy 값 (거짓으로 평가되는 값) 으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true 로, Falsy 값은 false 로 암묵적 타입 변환 된다.

아래 값들은 false 로 평가되는 Falsy 값이다.

```js
false
undefined
null
0, -0
Nan
'' (빈 문자열)
```

Falsy 값에 ! 연산자를 붙이면, 모두 Truthy 값으로 평가되어 실행 가능해진다.

```js
// 아래의 조건문은 모두 코드 블록을 실행한다.
if (!false) console.log(false + " is falsy value");
if (!undefined) console.log(undefined + " is falsy value");
if (!null) console.log(null + " is falsy value");
if (!0) console.log(0 + " is falsy value");
if (!NaN) console.log(NaN + " is falsy value");
if (!"") console.log("" + " is falsy value");
```

### 고차함수

고차 함수 (Higher-Order Function, HOF) 는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말하낟.

자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달할 수 있으며 반환할 수도 있다.

고차 함수는 외부 상태의 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에 기반을 두고있다.

### 객체 리터럴

자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체이다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식) 은 모두 객체이다. 원시 타입은 단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다.

```js
var person = {
  name: "Lee",
  age: 20,
};
```

### 함수와 메서드의 차이점

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드(method)라 부른다. 객체 내부에서 객체의 프로퍼티(상태)를 참조하고 조작할 수 있는 동작을 메서드라 부른다.

즉, 메서드는 객체에 묶여 있는 함수를 의미한다.

### 자바스크립트에서 객체를 생성하는 방법

자바스크립트는 '프로토타입 기반 객체지향 언어' 로써 '클래스 기반 객체지향 언어' 와는 달리 다양한 객체 생성 방법을 지원한다.

```
   1. 객체 리터럴
   2. Object 생성자 함수
   3. 생성자 함수
   4. Object.create 메서드
   5. 클래스(ES6)
```

### 전역 객체

- 전역 객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다.
- 클라이언트 사이드 환경(브라우저) 에서는 window, 서버 사이드 환경(Node.js) 에서는 global 객체를 의미한다.
- 전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array...) 들과 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

### 원시 값과 객체 비교

동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유

1. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value) 이다. 이에 비해 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.
2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간) 에는 참조 값(메모리 주소)이 저장된다.
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.

### 함수 선언문과 함수 표현식의 차이

함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.

### 스코프

스코프는 유효 범위 라는 뜻으로, 식별자(변수)가 유효한 범위를 말한다.

자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 따라서 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

스코프는 크게 전역 스코프와 지역 스코프로 구분된다.

이는 상대적인 개념이며 전역이란 코드의 가장 바깥 영역을 말한다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 이 전역 변수는 어디서든 참조할 수 잇다.

지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만드는데, 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.
지역 변수는 자신의 스코프와 하위 지역 스코프에서 유효하다.

### 렉시컬 스코프

함수를 어디서 '호출' 했는 지가 아닌 어디서 '정의' 했는 지에 따라 함수의 상위 스코프를 결정하는 것이 정적 스코프 즉, 렉시컬 스코프를 의미한다.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

소스코드의 실행에 있어서 foo 함수 내부에서 bar 함수를 '호출' 하더라도, bar 함수는 foo 함수와 동일한 스코프인 전역 스코프에 '정의' 되어 있기 때문에 foo 함수 내부의 x=10 을 참조할 수 없다.

따라서 foo, bar 의 호출한 결과는 모두 1로 반환된다. 이런 자바스크립트의 정적인 스코프 특징을 '렉시컬 스코프' 라고 한다.

### 함수와 일급 객체

#### 일급 객체

다음과 같은 조건을 만족하는 객체를 일급 객체 라 한다.

1. 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다.

일급 객체로써 함수가 가지는 가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 잇으며, 함수의 반환값으로 사용할 수도 있다는 것이다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중 하나이다.

#### 함수형 프로그래밍

외부 상태를 변경하지 않고, 외부 상태에 의존하지도 않는 함수를 순수 함수라고 한다. 순수 함수를 통해 side effect 를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.

- 순수함수 : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 side effect 가 없는 함수
- 비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 side effect 가 있는 함수

### 프로토타입

#### 객체지향 프로그래밍

여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

#### 객체지향 프로그래밍의 특징

1. 추상화
2. 캡슐화
3. 상속
4. 다형성

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

프로토타입은 상속을 구현하기 위해 사용된다.

자바스크립트에서 기본 데이터 타입을 제외한 모든 것은 객체이다.

객체가 만들어지기 위해서는 자신을 만드는 데 사용된 원형인 프로토타입 객체를 이용하여 객체를 만든다.

이때 만들어진 객체 안에 `__proto__` 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있다.

이 숨겨진 링크를 프로토타입이라고 한다.

`__proto__` 속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다.
이런 프로토타입 체인 구조 때문에 모든 객체는 Object 의 자식이라고 불리고, Object Prototype Object 에 있는 모든 속성을 사용할 수 있다.

### this

this 는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.

this 를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

this 는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.

단 this 가 가리키는 값 즉, this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

#### this 바인딩

바인딩이란 식별자(변수) 와 값(원시 값 또는 객체)을 연결하는 과정을 의미한다.

예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다.

this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다) 와 this 가 가리킬 객체를 바인딩하는 것이다.

### 실행 컨텍스트

실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

실행 컨텍스트는 ① 실행 컨택스트 스택, ② 렉시컬 환경으로 구성되어 있다.

① 실행 컨텍스트 스택은 코드의 실행 순서를 관리하는 자료구조로, L.I.F.O(Last In First Out) 구조로 들어오는 코드를 관리한다.

② 렉시컬 환경은 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다.

② 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.

즉, ② 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.

### 클로저

> 클로저는 자신이 선언될 당시의 환경을 기억하는 함수이다.

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 (실행 컨텍스트 스택에서 push 되더라도) 렉시컬 환경에 남아 참조가 가능하다.

#### 클로저의 장점

클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.

다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태변경을 허용하기 위해 사용한다.

#### 클로저 생성 방법

1. 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환 값으로 사용될 때
2. 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
3. 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때

```js
var name = `Global`;
function outer() {
  var name = `closure`;
  return function inner() {
    console.log(name);
  };
}

var callFunc = outer();
callFunc();
```

위 코드에서 `callFunc` 를 클로저라고 한다. `callFunc` 호출에 의해 name 이라는 값이 console 에 찍히는데, 찍히는 값은 `Global` 이 아니라 `closure` 라는 값이다. 즉, `outer` 함수의 `context` 에 속해있는 변수를 참조하는 것이다. 여기서 `outer` 함수의 지역변수로 존재하는 `name` 변수를 `free variable (자유변수)` 라고 한다.

이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 `클로저` 라고 한다.

### 브라우저 렌더링 과정

1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.

- 주소창에 직접 입력하거나, 클릭을 통해 해당 웹 페이지에 접근한다.
- 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.

2. 서버에서 응답으로 받은 HTML 데이터를 파싱한다. (바이트 -> 문자 -> 토큰 -> 노드 -> DOM)

- 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다.
- 이때 서버는 브라우저가 요청한 HTML 파일을 읽어들여 메모리에 저장한 다음 메모리에 저장된 바이트 (2진수)를 인터넷을 경유하여 응답한다.
- 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다.
- 따라서 응답된 바이트 형태의 HTML 문서를 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다.
- 문자열로 변환된 HTML 문서를 읽어들여 문법적 의미를 갖는 코드의 최소 단위인 토큰(token)들로 분해한다.
- 각 토큰들을 객체로 변환하여 노들들을 생성한다. 토큰의 내용에 따라 1. 문서 노드, 2. 요소 노드, 3. 어트리뷰트 노드, 4. 텍스트 노드가 생성된다.
